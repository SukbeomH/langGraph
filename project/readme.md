# Multi-Agent AI Chain of Thought, for Self Driven Action

```
project/
      ├── agents/              # 각 에이전트 모듈
      │   ├── specGenerator.js # 스펙 생성 에이전트
      │   ├── codeGenerator.js # 코드 생성 에이전트
      │   ├── tester.js       # 테스트 에이전트
      │   └── evaluator.js    # 평가 에이전트
      ├── graph/               # 그래프 관련 모듈
      │   ├── nodes.js        # 노드 정의
      │   ├── edges.js        # 엣지 정의
      │   └── pipeline.js     # 파이프라인 구성
      ├── storage/            # 저장소
      └── public/             # 프론트엔드 (기존 유지)
```

## Development Plan

### 1. 준비 단계
- **프로젝트 초기화**
  - Git 리포지토리 생성 및 기본 설정 (.gitignore, README.md 작성)
  - 파일트리 생성: package.json, index.js, core.js, 그리고 public/ 내의 index.html, style.css, app.js 파일 준비
- **기술 스택 및 환경 설정**
  - Node.js 및 Express 설치
  - 프론트엔드 기본 개발 환경 세팅

### 2. 백엔드 개발 (index.js & core.js)
- **Express 서버 구축 (index.js)**
  - 기본 API 엔드포인트 구성
  - 정적 파일 제공(public/ 디렉토리 연결)
- **핵심 기능 구현 (core.js)**
  - **LLM Assist 기능:** 자연어 입력을 받아 함수 스펙을 생성하는 로직 구현
  - **함수 생성 기능:** 스펙을 기반으로 HTTP Request 처리 함수를 자동 생성하는 코드 작성
  - **더미 HTTP Request 생성:** 테스트 데이터를 생성하는 함수 구현
  - **테스트 및 검증 기능:** 생성된 함수의 동작을 검증하고, 결과 및 설명을 기록하는 기능 추가
  - **저장 및 RAG 기능:** 테스트 결과와 생성된 함수 스펙을 JSON 파일에 저장하고, 이후 검색(RAG)할 수 있도록 기능 구현
- **단위 테스트 작성 및 검증**
  - 각 기능별로 간단한 테스트 코드를 작성하여 초기 버전의 동작 확인

### 3. 프론트엔드 개발 (public 디렉토리)
- **UI 설계 및 개발**
  - **index.html:** 기본 웹 페이지 레이아웃 구성
  - **style.css:** 심플하고 직관적인 UI 스타일링
  - **app.js:** API 호출, 결과 표시 및 LangGraph 기반 시각화 로직 구현 (D3.js나 vis.js 같은 라이브러리 활용)
- **시각화 기능**
  - LangGraph의 흐름(자연어 입력 → 함수 생성 → 테스트 결과 등)을 시각적으로 표시하는 인터페이스 설계
  - 실시간 데이터 흐름 업데이트 기능 구현

### 4. 통합 및 시스템 테스트
- **백엔드-프론트엔드 통합**
  - API 엔드포인트와 UI 연동 테스트 진행
  - 전체 파이프라인(자연어 입력 → 함수 생성 → 테스트 → 저장 및 시각화) 엔드투엔드(E2E) 테스트
- **디버깅 및 최적화**
  - 각 단계에서 발생하는 에러 및 예외 상황 처리
  - 로그 및 피드백 기능 추가

### 5. 문서화 및 배포 (마무리 단계)
- **최종 문서화**
  - README.md 업데이트 및 사용자 가이드 작성
  - 코드 주석 및 개발 문서 정리
- **배포 준비**
  - 최종 코드 리뷰 및 리팩토링
  - 필요한 경우, 간단한 CI/CD 파이프라인 구성

---

## Description

### 1. **모듈별 역할 분리**
- **LLM Assist 모듈**  
  - 자연어 요청을 받아 함수의 요구사항과 스펙을 생성합니다.
  - LangGraph의 **Agent** 역할로 활용할 수 있습니다.

- **함수 생성 모듈**  
  - LLM Assist가 생성한 스펙을 기반으로 HTTP Request 처리 함수를 만듭니다.
  - 여기서 HTTP 요청 분석, 차단, 분류, 변조 등의 로직을 구현합니다.

- **더미 HTTP Request 생성 모듈**  
  - 테스트용으로 다양한 더미 요청 데이터를 생성하는 역할입니다.
  - 간단한 AI 또는 정적/랜덤 데이터 생성 로직으로 구성할 수 있습니다.

- **테스트 및 검증 모듈**  
  - 생성된 함수를 더미 데이터에 대해 실행하고, 성공 여부와 설명을 기록합니다.
  - 평가(Evaluator-optimizer) 역할로 활용할 수 있습니다.

- **저장 및 RAG 모듈**  
  - 테스트 결과와 생성된 함수, 설명을 JSON으로 저장합니다.
  - 저장된 데이터를 기반으로 기존 코드를 참고하거나 그대로 사용하는 Retrieval Augmented Generation (RAG) 기능을 제공합니다.

- **시각화 및 UI 모듈**  
  - LangGraph의 여러 형태(프롬프트 체이닝, 병렬 처리, 라우팅, 오케스트레이터-워커 등)와 자연어 처리 과정을 웹 프론트에서 시각적으로 표현합니다.
  - 가볍고 직관적인 UI를 위해 간단한 HTML/JS 라이브러리를 활용합니다.

---

### 2. **데이터 플로우 & 간단한 Pipeline**
1. **자연어 입력**  
   - 사용자로부터 자연어 요청 입력
   - → **LLM Assist** 모듈에서 함수 스펙 생성

2. **함수 생성**  
   - 생성된 스펙을 바탕으로 함수 코드 자동 생성
   - → HTTP Request를 분석하고 처리하는 함수가 생성됨

3. **테스트 데이터 생성**  
   - **더미 HTTP Request 생성** 모듈에서 테스트 데이터를 제공

4. **함수 검증 및 평가**  
   - 테스트 데이터로 함수를 실행하여 결과 및 성공 여부 평가
   - → 결과와 설명을 기록 및 저장

5. **RAG 기능**  
   - 저장된 데이터(함수, 설명 등)를 검색하여 향후 요청에 활용

6. **시각화**  
   - 전체 프로세스를 LangGraph 기반의 그래프로 웹 프론트에서 실시간으로 표시

---

### 3. **구현 제안 및 기술 스택**
- **백엔드(Node.js):**  
  - 각 모듈(LLM Assist, 함수 생성, 테스트 등)을 개별 서비스 또는 함수로 구현  
  - Express.js를 사용해 간단한 API 서버 구성

- **프론트엔드(Vanilla JS):**  
  - LangGraph의 프로세스 시각화를 위해 D3.js, vis.js 같은 라이브러리 활용  
  - 모듈 간 데이터 흐름과 상태를 실시간으로 표시

- **저장소:**  
  - JSON 파일로 함수 및 테스트 결과 저장

- **LangGraph 활용:**  
  - 각 모듈을 LangGraph의 노드로 매핑하여 시각적 흐름(프롬프트 체이닝, 라우팅 등)을 구성  
  - 필요에 따라 Orchestrator-Worker 패턴을 단순화하여 구현

---

### 4. **구현 시 유의 사항**
- **모듈 간 인터페이스 정의:**  
  - 각 모듈이 반환하는 데이터 구조와 입력 파라미터를 명확히 정의하여 통합 시 혼란 방지

- **점진적 MVP 개발:**  
  - 모든 기능을 한 번에 구현하기보다, 자연어 입력 → 함수 생성 → 테스트 실행 → 결과 저장의 핵심 파이프라인을 먼저 구축하고, 그 위에 시각화 및 RAG 기능을 추가

- **오류 처리 및 피드백:**  
  - 각 단계별로 성공/실패 여부와 설명을 기록하여, 디버깅 및 향후 개선에 활용

---

### 5. **요약**
- **모듈화:** 각 기능(자연어 요청, 함수 생성, 테스트, 저장, 시각화)을 독립 모듈로 분리  
- **단순 데이터 플로우:** 자연어 입력 → 함수 생성 → 테스트 → 결과 저장 → RAG 활용  
- **시각화:** LangGraph의 다양한 역할을 웹 UI로 간단하고 직관적으로 구현  
- **점진적 개발:** MVP를 먼저 만들고, 추가 기능(세부 평가, 최적화, 고급 시각화)을 차후 확장
